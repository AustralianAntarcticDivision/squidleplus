% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/requests.R
\name{sq_req_query}
\alias{sq_req_query}
\title{Construct a squidleplus API query}
\usage{
sq_req_query(filters, limit, offset, order_by, group_by, single)
}
\arguments{
\item{filters}{list: a list of one of the following forms:
* `list(name = "fieldname", op = "operatorname", val = "argument")` where <operatorname> is one of the strings described below, <argument> is a value to be used as the second argument to the given operator and <fieldname> is the name of the field of the model to which to apply the operator, which can be either a MODEL COLUMN, RELATED MODEL, ASSOCIATION PROXY or HYBRID ATTRIBUTE for a resource
* `list(name = "fieldname", op = "operatorname", field = "fieldname")` where the first <fieldname> and <operatorname> are as above and the second <fieldname> is the field of the model that should be used as the second argument to the operator. The first <fieldname> may specify a field on a related model, if it is a string of the form <relationname>__<fieldname>. Alternatively if the field name is the name of a relation and the operator is "has" or "any", the "val" argument can be a dictionary with the arguments representing another, nested filter to be applied as the argument for "has" or "any"
Filters can also exclude results, for example `list(not = <filterobject>)`.
Filter objects can also be arbitrary boolean formulas, for example `list(or = <filterobject>, list(and = <filterobject>, ...), ...)`
Filter objects can also be defined on hybrid attributes of a model. Hybrid property filter objects are defined in the same way as column fields, but to filter by a hybrid method with one or more input arguments (<arg1>, <arg2>, ...,  <argN>), the object can be defined as:
`list(name = list(method = "method_name", args = list(<arg1>, <arg2>, ..., <argN>)), op = "operatorname", val = "argument")`
The returned list of matching instances will include only those instances that satisfy all of the given filters. If a filter is poorly formatted (for example, op is set to '==' but val is not set), the server responds with 400 Bad Request.}

\item{limit}{integer: a positive integer which specifies the maximum number of objects to return}

\item{offset}{integer: a positive integer which specifies the offset into the result set of the returned list of instances}

\item{order_by}{list: a list of objects of the form:
* `list(field = "fieldname", direction = "directionname")` where <fieldname> is a string corresponding to the name of a field of the requested model and <directionname> is either "asc" for ascending order or "desc" for descending order. <fieldname> may alternately specify a field on a related model, if it is a string of the form <relationname>__<fieldname>. Ordering can also be defined on hybrid attributes of a model. Hybrid property order_by objects are defined in the same way as column fields, but to filter by a hybrid method with one or more input arguments (<arg1>, <arg2>, ..., <argN>), the object can be defined as: `list(field = list(method = "method_name", args = list(<arg1>, <arg2>, ..., <argN>)), direction = "directionname")`}

\item{group_by}{list: a list of the form `list(field = "fieldname")` where `fieldname` is a string corresponding to the name of a field of the requested model. `fieldname` may alternately specify a field on a related model, if it is a string of the form `relationname__fieldname`}

\item{single}{logical: whether a single result is expected as a result of the search. If this is true and either no results or multiple results meet the criteria of the search, the server responds with an error message}
}
\value{
A list object that will be converted to a JSON-formatted string when added to an API query
}
\description{
The query parameter q must be a JSON string of the form `{"filters":[...],"limit":...,"offset":...,"order_by":[...],"group_by":[...],"single":...}`. All parameters are optional.
}
\details{
The <operatorname> strings recognized by the API include:
* `==`, `eq`, `equals`, `equals_to` - "equal to" operator, where val can be numeric or string
* `!=`, `neq`, `does_not_equal`, `not_equal_to` - "not equal to" operator, where val can be numeric or string
* `>`, `gt`, `<`, `lt` - "less/greater than" operator, where val is typically numeric
* `>=`, `ge`, `gte`, `geq`, `<=`, `le`, `lte`, `leq` - "less/greater than or equal to" operator, where val is typically numeric
* `in`, `not_in` - "is in" operator, where val is typically a list of values
* `is_null`, `is_not_null` - "is null" check, where there is no val param
* `like`, `ilike`: - "like" (case sensitive) or "ilike" (case insensitive) comparison, where val is a string. Wildcards can be included as a % symbol (or %25 url-encoded).
* `has` - for nesting operators on a relation that is a single object (i.e.: MANYTOONE)
* `any` - for nesting operators on a relation that is a list of objects (i.e.: ONETOMANY/MANYTOMANY)

For geometry columns, there are also some spatial operators for <operatorname>, which include:
* `geo_at` - Geometry / Geography type <fieldname> is close to a nominated lat/lon. The val takes the form: {"lat":...,"lon":...,"dist":...} where dist is optional and defaults to 0.00005. For Geometry types dist is in srid units (eg: degrees), for Geography types it is meters. Hint: assume Geometry types most of the time.
* `geo_in_bbox` - Geometry / Geography type <fieldname> is within a bounding box. The val takes the form: [p1,p2], which is a list containing two elements being two diagonal points defining the bounding box, eg: [bottom-left, top-right]. p1,p2 are position objects of the form, {"lat":...,"lon":...}
* `geo_in_poly` - Geometry / Geography type <fieldname> is within a polygon. The val is a polygon list of points of the form: [p1,p2,p3,...,pn,p1], where p1-pn are position objects of the form {"lat":..., "lon":...}. Note the polygon is closed, being that it starts and ends wth p1.
}
\examples{

## get all media_collections that contain media from a campaign matching the key "Batemans201011"
sq_req_query(filters =
  sq_v(media \%any\% sq_v(deployment \%has\% sq_v(campaign \%has\% sq_v(key == "Batemans201011")))))
## equivalent to
## {"filters":[{"name":"media", "op":"any",
##    "val":{"name":"deployment", "op":"has",
##      "val":{"name":"campaign", "op":"has",
##        "val":{"name":"key", "op":"eq", "val":"Batemans201011"}}}}]}

## search for all media that contains annotations with the name that
##  includes "ecklonia" (ignoring case)
sq_req_query(filters = sq_v(annotations \%any\% sq_v(annotations \%any\%
               sq_v(label \%has\% sq_v(name \%ilike\% "\%ecklonia\%")))))

}
\references{
<https://squidle.org/api/help?template=api_help_page.html#api_query>
}
\seealso{
[sq_query()] [sq_v()]
}
